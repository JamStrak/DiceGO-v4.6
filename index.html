<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÁªùÂ¢ÉÈ™∞Â≠ê - V7.5 Âπ≥Ë°°‰∏éÁâ©ÁêÜÂ¢ûÂº∫Áâà</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; touch-action: none; color: white;}
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; flex-direction: column; justify-content: space-between; z-index: 10; }
        .top-bar { display: flex; justify-content: space-between; padding: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); pointer-events: auto;}
        .stat-box { text-align: right; text-shadow: 1px 1px 2px black; }
        .stat-big { font-size: 24px; font-weight: bold; color: #ffcc00; }
        .stat-small { font-size: 12px; color: #aaa; }
        #control-btn { background: rgba(0, 0, 0, 0.5); border: 1px solid #00ff00; color: #00ff00; padding: 8px 16px; border-radius: 20px; font-weight: bold; cursor: pointer; }
        .xp-bar-container { position: absolute; top: 60px; left: 5%; width: 90%; height: 6px; background: #222; border-radius: 3px; border: 1px solid #444; overflow: hidden;}
        #xp-fill { width: 0%; height: 100%; background: #00ff00; transition: width 0.2s; }
        #level-badge { position: absolute; top: 40px; left: 50%; transform: translateX(-50%); font-size: 14px; font-weight: bold; color: #fff; text-shadow: 0 0 5px #00ff00; }
        .bottom-bar { padding: 30px; display: flex; justify-content: center; align-items: flex-end; }
        .hp-container { width: 300px; max-width: 80%; text-align: center; }
        .hp-track { width: 100%; height: 20px; background: #333; border: 2px solid #fff; border-radius: 6px; overflow: hidden; position: relative; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
        .hp-fill { width: 100%; height: 100%; background: #ff3333; transition: width 0.1s; }
        .hp-text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; line-height: 20px; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; backdrop-filter: blur(4px); }
        .btn-start { padding: 15px 60px; font-size: 24px; font-weight: 900; background: #ffcc00; color: #000; border: none; transform: skew(-10deg); cursor: pointer; box-shadow: 0 0 20px rgba(255, 204, 0, 0.4); transition: 0.2s; margin-top: 30px; }
        .btn-start:active { transform: skew(-10deg) scale(0.95); }
        .card-grid { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 800px; padding: 10px; }
        .card { background: linear-gradient(135deg, #222, #111); border: 1px solid #555; width: 160px; padding: 15px; border-radius: 8px; cursor: pointer; display: flex; flex-direction: column; align-items: center; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.5); transition: 0.2s; }
        .card:hover { border-color: #fff; transform: translateY(-5px); background: #333; }
        .card h3 { color: #ffcc00; font-size: 16px; margin: 0 0 10px 0; }
        .card p { font-size: 12px; color: #ccc; line-height: 1.4; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <button id="control-btn" onclick="toggleControl()">üïπÔ∏è ÊëáÊùÜ (Q)</button>
            <div class="stat-box">
                <div class="stat-big">‚ò†Ô∏è <span id="ui-kills">0</span></div>
                <div class="stat-small" id="ui-time">00:00</div>
            </div>
        </div>
        <div id="level-badge">LV.<span id="ui-lvl">1</span></div>
        <div class="xp-bar-container"><div id="xp-fill"></div></div>

        <div class="bottom-bar">
            <div class="hp-container">
                <div class="hp-track">
                    <div class="hp-fill" id="hp-fill"></div>
                    <div class="hp-text" id="hp-text">100/100</div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-start" class="overlay">
        <h1 style="font-size: 40px; color: #ffcc00; margin:0;">PROJECT<br>DICE SURVIVOR</h1>
        <p style="color:#888; letter-spacing: 2px;">V7.5 Âπ≥Ë°°Áâà</p>
        <p style="color:#fff;">ÂéÜÂè≤ÊúÄÈ´ò: <span id="best-score">0</span></p>
        <button class="btn-start" onclick="gameStart()">DEPLOY</button>
    </div>

    <div id="screen-levelup" class="overlay" style="display: none;">
        <h2 style="color:#fff;">Á≥ªÁªüÂçáÁ∫ß</h2>
        <div class="card-grid" id="upgrade-container"></div>
    </div>

    <div id="screen-over" class="overlay" style="display: none;">
        <h1 style="color:#ff3333; font-size: 50px;">‰ªªÂä°Â§±Ë¥•</h1>
        <h2 style="color:#fff;">ÂáªÊùÄÊï∞: <span id="end-kills">0</span></h2>
        <button class="btn-start" onclick="location.reload()">RESTART</button>
    </div>

    <script>

    const C = {
        MAP_SIZE: 2500,
        ZOOM: 0.6,
        PLAYER: { HP: 100, SPEED: 8, INV_TIME: 100 }, 
        SPAWN: { START_DELAY: 1000, MIN_DELAY: 150 }, // ÊúÄÂ∞èÂà∑ÊÄ™Èó¥ÈöîÁ®çÂæÆË∞ÉÂ§ß‰∏ÄÁÇπ
        CAT: {
            PLAYER: 0x0001,
            ENEMY:  0x0002,
            DIE:    0x0004,
            BULLET: 0x0008,
            WALL:   0x0010,
            ITEM:   0x0020
        }
    };

    let game, scene;
    let inputMode = 'joystick';
    document.getElementById('best-score').innerText = localStorage.getItem('pds_best') || 0;

    function gameStart() {
        document.getElementById('screen-start').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'flex';
        
        game = new Phaser.Game({
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: '#111',
            scale: { mode: Phaser.Scale.RESIZE },
            physics: {
                default: 'matter',
                matter: { 
                    gravity: { y: 0 }, 
                    positionIterations: 6, 
                    velocityIterations: 4,
                    runner: { isFixed: true, fps: 60 } 
                } 
            },
            scene: MainScene
        });
    }

    function toggleControl() {
        inputMode = inputMode === 'joystick' ? 'click' : 'joystick';
        const btn = document.getElementById('control-btn');
        btn.innerText = inputMode === 'joystick' ? 'üïπÔ∏è ÊëáÊùÜ (Q)' : 'üéØ ÁÇπÂáª (Q)';
        btn.style.borderColor = inputMode === 'joystick' ? '#00ff00' : '#00ffff';
        btn.style.color = btn.style.borderColor;
        if(scene) scene.resetInput();
    }

    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            const gen = (k, c, w, h, type) => {
                if(this.textures.exists(k)) return;
                const g = this.make.graphics({add:false});
                g.fillStyle(c, 1); g.lineStyle(2, 0xffffff);
                if(type === 'rect') { g.fillRect(0,0,w,h); g.strokeRect(0,0,w,h); }
                if(type === 'circle') { g.fillCircle(w/2,h/2,w/2); g.strokeCircle(w/2,h/2,w/2); }
                if(type === 'tri') { g.beginPath(); g.moveTo(w/2,0); g.lineTo(w,h); g.lineTo(0,h); g.closePath(); g.fillPath(); g.strokePath(); }
                g.generateTexture(k, w, h);
            };

            gen('player', 0x00ffff, 32, 32, 'rect');
            gen('enemy', 0xff3333, 28, 28, 'rect');
            gen('enemy_s', 0x9933ff, 32, 32, 'tri');
            gen('enemy_e', 0xff8800, 96, 96, 'rect');
            gen('bullet', 0xffaa00, 14, 14, 'circle'); // Â≠êÂºπÁ®çÂæÆÂ§ß‰∏ÄÁÇπ
            gen('item_hp', 0x00ff00, 24, 24, 'rect');
            gen('item_xp', 0xffd700, 28, 28, 'circle');
            
            const g = this.make.graphics({add:false});
            g.lineStyle(1, 0x333333); g.strokeRect(0,0,128,128);
            g.generateTexture('grid', 128, 128);

            this.generateDiceTextures();
        }

        generateDiceTextures() {
            const size = 30;
            const dotSize = 3.5;
            const positions = {
                1: [[0.5, 0.5]],
                2: [[0.25, 0.25], [0.75, 0.75]],
                3: [[0.25, 0.25], [0.5, 0.5], [0.75, 0.75]],
                4: [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]],
                5: [[0.25, 0.25], [0.75, 0.25], [0.5, 0.5], [0.25, 0.75], [0.75, 0.75]],
                6: [[0.25, 0.2], [0.75, 0.2], [0.25, 0.5], [0.75, 0.5], [0.25, 0.8], [0.75, 0.8]]
            };

            for (let i = 1; i <= 6; i++) {
                if (this.textures.exists(`die_${i}`)) continue;
                const g = this.make.graphics({add: false});
                g.fillStyle(0xffffff);
                g.fillRoundedRect(0, 0, size, size, 5);
                g.lineStyle(2, 0x999999);
                g.strokeRoundedRect(0, 0, size, size, 5);
                g.fillStyle(0x000000);
                positions[i].forEach(pos => {
                    g.fillCircle(size * pos[0], size * pos[1], dotSize);
                });
                g.generateTexture(`die_${i}`, size, size);
            }
        }

        create() {
            scene = this;
            this.matter.world.setBounds(0, 0, C.MAP_SIZE, C.MAP_SIZE);
            
            const wallThick = 2000;
            const mid = C.MAP_SIZE/2;
            const wallOpt = { isStatic: true, label: 'wall' };
            const walls = [
                this.matter.add.rectangle(mid, -wallThick/2, C.MAP_SIZE, wallThick, wallOpt),
                this.matter.add.rectangle(mid, C.MAP_SIZE+wallThick/2, C.MAP_SIZE, wallThick, wallOpt),
                this.matter.add.rectangle(-wallThick/2, mid, wallThick, C.MAP_SIZE, wallOpt),
                this.matter.add.rectangle(C.MAP_SIZE+wallThick/2, mid, wallThick, C.MAP_SIZE, wallOpt)
            ];
            walls.forEach(w => { w.collisionFilter = { category: C.CAT.WALL }; });

            this.add.tileSprite(mid, mid, C.MAP_SIZE, C.MAP_SIZE, 'grid').setDepth(-1);
            this.add.rectangle(mid, mid, C.MAP_SIZE, C.MAP_SIZE).setStrokeStyle(10, 0xff0000, 0.5);

            this.player = this.matter.add.sprite(mid, mid, 'player');
            this.player.name = 'player'; 
            this.player.setFixedRotation();
            this.player.setFrictionAir(0.15);
            this.player.setDensity(5);
            this.player.setDepth(100);
            this.player.setCollisionCategory(C.CAT.PLAYER);
            this.player.setCollidesWith([C.CAT.ENEMY, C.CAT.BULLET, C.CAT.WALL, C.CAT.ITEM]); 
            this.player.setData('hp', C.PLAYER.HP);
            this.player.setData('maxHp', C.PLAYER.HP);

            this.cameras.main.setZoom(C.ZOOM);
            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

            this.dataState = { level: 1, xp: 0, nextXp: 10, kills: 0, time: 0 };
            this.build = { 
                diceCount: 1, size: 1.0, speed: 1.0, radius: 120, cooldown: 1000, 
                friction: 0.05, impactDmg: 20, 
                laserDmgMult: 1.0, freezeChance: 0.2, explodeDmgMult: 1.0,
                densityMult: 1.0 // Êñ∞Â¢ûÔºöÂØÜÂ∫¶Á≥ªÊï∞
            };
            this.enemies = [];
            this.diceList = [];
            this.bullets = []; // ÁÆ°ÁêÜÂ≠êÂºπ
            this.items = []; 
            this.lastHurtTime = 0;
            this.isPaused = false;

            this.setupInput();
            this.setupCollisions();

            this.time.addEvent({ delay: 1000, loop: true, callback: this.updateTime, callbackScope: this });
            this.spawnEvent = this.time.addEvent({ delay: C.SPAWN.START_DELAY, loop: true, callback: this.spawnEnemy, callbackScope: this });
            this.hpGraphics = this.add.graphics().setDepth(150);
            this.updateUI();
        }

        setupCollisions() {
            const check = (pair, n1, n2, cb) => {
                const { bodyA, bodyB } = pair;
                const objA = bodyA.gameObject; const objB = bodyB.gameObject;
                if (!objA || !objB) return;
                if ((objA.name === n1 && objB.name === n2)) cb(objA, objB);
                else if ((objB.name === n1 && objA.name === n2)) cb(objB, objA);
            };

            this.matter.world.on('collisionstart', (event) => {
                event.pairs.forEach(pair => {
                    check(pair, 'die', 'enemy', (die, enemy) => {
                        if(!die.active || !enemy.active) return;
                        
                        if(enemy.getData('type') === 'elite') {
                             const dmg = this.build.impactDmg * 2; 
                             this.showDmg(enemy.x, enemy.y, dmg, '#fff');
                             this.hitEnemy(enemy, dmg);
                             
                             if (!die.doomed) {
                                 die.doomed = true;
                                 die.setTint(0xffaa00);
                                 this.time.delayedCall(100, () => { if(die.active) this.explodeDie(die); });
                             }
                        } else {
                            if (die.body.speed > 0.5) {
                                const dmg = this.build.impactDmg;
                                this.showDmg(enemy.x, enemy.y, dmg, '#fff');
                                this.hitEnemy(enemy, dmg);
                                const impact = this.add.circle(die.x, die.y, 20, 0xffffff, 0.6);
                                this.tweens.add({targets:impact, scale:0.2, alpha:0, duration:100, onComplete:()=>impact.destroy()});
                            }
                        }
                    });
                    check(pair, 'player', 'bullet', (p, b) => { this.hitPlayer(5); b.destroy(); });
                    check(pair, 'bullet', 'wall', (b, w) => { b.destroy(); }); // Â≠êÂºπÊíûÂ¢ôÈîÄÊØÅ
                    
                    check(pair, 'player', 'item_hp', (p, item) => { 
                        this.healPlayer(30); 
                        this.items = this.items.filter(i => i !== item);
                        item.destroy(); 
                    });
                    check(pair, 'player', 'item_xp', (p, item) => { 
                        this.gainXp(100);
                        const txt = this.add.text(p.x, p.y-40, "XP MAX", {color:'#ffd700', fontSize:20, fontStyle:'bold'}).setOrigin(0.5);
                        this.tweens.add({targets:txt, y:p.y-80, alpha:0, duration:800, onComplete:()=>txt.destroy()});
                        this.items = this.items.filter(i => i !== item);
                        item.destroy(); 
                    });
                });
            });

            this.matter.world.on('collisionactive', (event) => {
                event.pairs.forEach(pair => {
                    check(pair, 'player', 'enemy', (p, e) => {
                        if (!e.getData('frozen')) this.hitPlayer(10);
                    });
                    check(pair, 'die', 'enemy', (die, enemy) => {
                        if (die.body.speed > 0.2 && scene.time.now % 10 === 0 && enemy.getData('type') !== 'elite') {
                            this.hitEnemy(enemy, 1); 
                        }
                    });
                });
            });
        }

        setupInput() {
            this.input.keyboard.on('keydown-Q', toggleControl);
            this.joyStick = { active: false, x: 0, y: 0, vec: new Phaser.Math.Vector2() };
            this.clickDest = null;
            this.marker = this.add.circle(0,0,10,0x00ff00).setVisible(false).setDepth(90);
            this.joyBase = this.add.circle(0,0,60,0xffffff,0.1).setScrollFactor(0).setVisible(false).setDepth(999);
            this.joyThumb = this.add.circle(0,0,30,0xffffff,0.5).setScrollFactor(0).setVisible(false).setDepth(999);

            this.input.on('pointerdown', p => {
                if(this.isPaused || p.y < 80) return;
                if(inputMode === 'click') {
                    const wp = this.cameras.main.getWorldPoint(p.x, p.y);
                    this.clickDest = new Phaser.Math.Vector2(wp.x, wp.y);
                    this.marker.setPosition(wp.x, wp.y).setVisible(true);
                } else {
                    this.joyStick.active = true;
                    this.joyStick.x = p.x; this.joyStick.y = p.y;
                    this.joyBase.setPosition(p.x, p.y).setVisible(true);
                    this.joyThumb.setPosition(p.x, p.y).setVisible(true);
                }
            });
            this.input.on('pointermove', p => {
                if(this.joyStick.active) {
                    const d = Phaser.Math.Distance.Between(this.joyStick.x, this.joyStick.y, p.x, p.y);
                    const a = Phaser.Math.Angle.Between(this.joyStick.x, this.joyStick.y, p.x, p.y);
                    const dist = Math.min(d, 60);
                    this.joyThumb.x = this.joyStick.x + Math.cos(a)*dist;
                    this.joyThumb.y = this.joyStick.y + Math.sin(a)*dist;
                    this.joyStick.vec.set(Math.cos(a), Math.sin(a));
                }
            });
            this.input.on('pointerup', () => {
                this.joyStick.active = false;
                this.joyBase.setVisible(false); this.joyThumb.setVisible(false);
                this.joyStick.vec.set(0,0);
            });
        }

        resetInput() {
            this.clickDest = null;
            this.joyStick.active = false;
            this.joyBase.setVisible(false); this.joyThumb.setVisible(false);
            this.player.setVelocity(0);
        }

        update(t, dt) {
            if(this.isPaused) return;
            this.drawHpBars();

            if(inputMode === 'click' && this.clickDest) {
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.clickDest.x, this.clickDest.y);
                if(dist > 10) {
                    const a = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.clickDest.x, this.clickDest.y);
                    this.player.setVelocity(Math.cos(a)*C.PLAYER.SPEED, Math.sin(a)*C.PLAYER.SPEED);
                } else {
                    this.player.setVelocity(0); this.clickDest = null; this.marker.setVisible(false);
                }
            } else if (inputMode === 'joystick') {
                this.player.setVelocity(this.joyStick.vec.x * C.PLAYER.SPEED, this.joyStick.vec.y * C.PLAYER.SPEED);
            }
            
            const b = 40; 
            if (this.player.x < b) { this.player.setX(b); this.player.setVelocityX(0); }
            if (this.player.x > C.MAP_SIZE - b) { this.player.setX(C.MAP_SIZE - b); this.player.setVelocityX(0); }
            if (this.player.y < b) { this.player.setY(b); this.player.setVelocityY(0); }
            if (this.player.y > C.MAP_SIZE - b) { this.player.setY(C.MAP_SIZE - b); this.player.setVelocityY(0); }

            if(!this.nextFire || t > this.nextFire) {
                this.fireDice();
                this.nextFire = t + this.build.cooldown;
            }

            this.enemies.forEach(e => {
                if(!e.active) return;
                if (e.getData('frozen')) {
                    e.setVelocity(0, 0); e.setAngularVelocity(0); return; 
                }
                const dist = Phaser.Math.Distance.Between(e.x, e.y, this.player.x, this.player.y);
                if(e.data.get('type') === 'shooter' && dist < 450) {
                    if(t > e.data.get('nextShot')) {
                        this.fireEnemyBullet(e);
                        e.data.set('nextShot', t + 2000);
                    }
                    e.setVelocity(e.body.velocity.x * 0.9, e.body.velocity.y * 0.9); 
                } else {
                    const angle = Phaser.Math.Angle.Between(e.x, e.y, this.player.x, this.player.y);
                    const speed = e.data.get('speed');
                    e.setVelocity(Math.cos(angle)*speed, Math.sin(angle)*speed);
                }
            });

            this.diceList.forEach((d, i) => {
                if (d.doomed) return; 
                d.life++;
                if (t > d.nextRollTime && d.body.speed > 1) {
                    d.setTexture(`die_${Phaser.Math.Between(1, 6)}`);
                    d.nextRollTime = t + 80;
                }
                if(d.body.speed < 1.0 && d.life > 10) {
                    this.explodeDie(d);
                    this.diceList.splice(i, 1);
                }
                if(d.life > 240) { 
                    this.explodeDie(d);
                    this.diceList.splice(i, 1);
                }
            });
        }

        drawHpBars() {
            this.hpGraphics.clear();
            this.enemies.forEach(e => {
                if (!e.active || e.getData('type') !== 'elite') return;
                const max = e.getData('maxHp');
                const cur = e.getData('hp');
                const pct = Phaser.Math.Clamp(cur/max, 0, 1);
                const w = 80; const h = 8;
                const x = e.x - w/2; const y = e.y - e.height/2 - 20;
                this.hpGraphics.fillStyle(0x000000, 0.8);
                this.hpGraphics.fillRect(x, y, w, h);
                this.hpGraphics.fillStyle(0x00ff00, 1);
                this.hpGraphics.fillRect(x+1, y+1, (w-2)*pct, h-2);
            });
        }

        spawnEnemy() {
            if(this.isPaused) return;
            let count = 1 + Math.floor(this.dataState.level / 5);
            
            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 1000;
                let x = this.player.x + Math.cos(angle) * r;
                let y = this.player.y + Math.sin(angle) * r;
                x = Phaser.Math.Clamp(x, 100, C.MAP_SIZE-100);
                y = Phaser.Math.Clamp(y, 100, C.MAP_SIZE-100);

                let type = 'enemy', hp = 10, speed = 4 + Math.random(), density = 0.5; 
                let isElite = false;

                const roll = Math.random();
                if(roll < 0.05) { 
                    type = 'enemy_e'; hp = 200; speed = 2; isElite = true; density = 20; 
                } else if (roll < 0.25) {
                    type = 'enemy_s'; hp = 15; speed = 3;
                }

                // 2. ‰øÆÊîπÁÇπÔºöÊõ¥Âπ≥ÊªëÁöÑË°ÄÈáèÊàêÈïø
                if (isElite) {
                    hp = 200 * (1 + this.dataState.level * 0.25); // Á≤æËã±ÊàêÈïø‰æùÁÑ∂ËæÉÂø´
                } else {
                    hp = hp * (1 + this.dataState.level * 0.1); // ÊôÆÈÄöÊÄ™ÊàêÈïøÂáèÁºì
                }

                const e = this.matter.add.sprite(x, y, type);
                e.name = 'enemy'; 
                if(type === 'enemy_s') e.setData('type', 'shooter');
                else if(isElite) e.setData('type', 'elite');
                else e.setData('type', 'chaser');

                e.setData('hp', hp); e.setData('maxHp', hp); 
                e.setData('speed', speed); e.setData('frozen', false); 
                if(type==='enemy_s') e.setData('nextShot', this.time.now + 1000);

                e.setCollisionCategory(C.CAT.ENEMY);
                e.setCollidesWith([C.CAT.PLAYER, C.CAT.DIE, C.CAT.WALL, C.CAT.ENEMY]);
                e.setDensity(density);
                e.setFrictionAir(0.05);
                this.enemies.push(e);
            }
        }

        fireEnemyBullet(e) {
            if (e.getData('frozen')) return; 
            const b = this.matter.add.sprite(e.x, e.y, 'bullet');
            b.name = 'bullet'; b.setSensor(true);
            b.setCollisionCategory(C.CAT.BULLET); b.setCollidesWith([C.CAT.PLAYER, C.CAT.WALL]);
            const a = Phaser.Math.Angle.Between(e.x, e.y, this.player.x, this.player.y);
            // 1. ‰øÆÊîπÁÇπÔºöÊèêÈ´òÂ≠êÂºπÈÄüÂ∫¶ÔºåÁßªÈô§ÈòªÂäõ
            b.setVelocity(Math.cos(a)*7, Math.sin(a)*7);
            b.setFrictionAir(0); 
            this.time.delayedCall(3500, ()=> { if(b.active) b.destroy(); });
        }

        fireDice() {
            for(let i=0; i<this.build.diceCount; i++) {
                this.time.delayedCall(i*100, () => {
                    let angle = 0; let nearest = null; let minD = 999999;
                    this.enemies.forEach(e => {
                        if (!e.active) return;
                        const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, e.x, e.y);
                        if (d < minD) { minD = d; nearest = e; }
                    });

                    if (nearest && minD < 800) {
                        angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, nearest.x, nearest.y);
                    } else if (this.player.body.speed > 0.5) {
                        angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                    } else {
                        angle = Math.random() * 6.28;
                    }
                    angle += Phaser.Math.FloatBetween(-0.1, 0.1);

                    const spawnOffset = 50;
                    const spawnX = this.player.x + Math.cos(angle) * spawnOffset;
                    const spawnY = this.player.y + Math.sin(angle) * spawnOffset;
                    const size = 30 * this.build.size;
                    
                    const d = this.matter.add.sprite(spawnX, spawnY, 'die_1');
                    d.name = 'die'; d.life = 0;
                    d.finalPoint = Phaser.Math.Between(1, 6);
                    d.nextRollTime = 0;
                    d.doomed = false;

                    d.setBody({type: 'rectangle', width: size, height: size});
                    d.setDisplaySize(size, size); 
                    d.setCollisionCategory(C.CAT.DIE);
                    d.setCollidesWith([C.CAT.ENEMY, C.CAT.WALL]);
                    d.setBounce(0.4); 
                    d.setFrictionAir(this.build.friction); 
                    // 3. ‰øÆÊîπÁÇπÔºöÂ∫îÁî®ÂØÜÂ∫¶Á≥ªÊï∞
                    d.setDensity(20 * this.build.densityMult); 

                    const spd = 12 * this.build.speed;
                    d.setVelocity(Math.cos(angle)*spd, Math.sin(angle)*spd);
                    d.setAngularVelocity(Math.random() * 0.5 - 0.25);
                    this.diceList.push(d);
                });
            }
        }

        explodeDie(d) {
            if(!d.active) return;
            d.setCollisionCategory(0); 
            d.setVelocity(0,0);
            d.setStatic(true); 
            d.setRotation(0);
            d.setTexture(`die_${d.finalPoint}`);
            
            const point = d.finalPoint;
            const isCrit = point === 6;
            const radius = this.build.radius * (isCrit ? 1.5 : 1);
            const dmg = point * 10 * (isCrit ? 2 : 1) * this.build.explodeDmgMult; 

            this.showDmg(d.x, d.y - 25, point, isCrit ? '#ff0' : '#0ff', isCrit ? 40 : 24);

            const c = this.add.circle(d.x, d.y, 10, isCrit?0xffd700:0xffffff, 0.5);
            this.tweens.add({targets:c, scale: radius/10, alpha:0, duration:200});

            if (point % 2 === 0) {
                let nearest = null; let minD = 600; 
                this.enemies.forEach(e => {
                    if (!e.active) return;
                    const dist = Phaser.Math.Distance.Between(d.x, d.y, e.x, e.y);
                    if (dist < minD) { minD = dist; nearest = e; }
                });
                if (nearest) {
                    const laser = this.add.graphics();
                    laser.lineStyle(point * 2, 0x00ffff, 1); 
                    laser.lineBetween(d.x, d.y, nearest.x, nearest.y);
                    this.tweens.add({targets: laser, alpha: 0, duration: 300, onComplete: ()=>laser.destroy()}); 
                    this.hitEnemy(nearest, dmg * 1.5 * this.build.laserDmgMult);
                }
            }

            let freezeSuccess = false;
            if (point % 2 !== 0 && Math.random() < this.build.freezeChance) freezeSuccess = true;

            for(let i = this.enemies.length - 1; i >= 0; i--) {
                const e = this.enemies[i];
                if(!e.active) continue;
                const dist = Phaser.Math.Distance.Between(d.x, d.y, e.x, e.y);
                if(dist <= radius) {
                    const angle = Phaser.Math.Angle.Between(d.x, d.y, e.x, e.y);
                    const force = 0.1 * this.build.size;
                    e.applyForce({x:Math.cos(angle)*force, y:Math.sin(angle)*force});
                    this.hitEnemy(e, dmg);
                    
                    if (freezeSuccess) {
                        e.setData('frozen', true);
                        e.setTint(0x00aaff); 
                        this.time.delayedCall(2000, () => {
                            if (e.active) {
                                e.setData('frozen', false);
                                e.clearTint();
                            }
                        });
                    }
                }
            }
            
            this.time.delayedCall(250, () => { if(d.active) d.destroy(); });
        }

        showDmg(x, y, dmg, color, size=16) {
            const txt = this.add.text(x, y, Math.floor(dmg), { fontSize: size, fontStyle: 'bold', color: color, stroke: '#000', strokeThickness: 2 }).setOrigin(0.5).setDepth(200);
            this.tweens.add({targets:txt, y:y-40, alpha:0, duration:600, onComplete:()=>txt.destroy()});
        }

        hitEnemy(e, dmg) {
            let hp = e.getData('hp');
            hp -= dmg;
            e.setData('hp', hp);
            if(hp <= 0) {
                if(e.getData('type') === 'elite') {
                    const hpCount = this.items.filter(i => i.active && i.name === 'item_hp').length;
                    let dropType = (hpCount >= 5) ? 'item_xp' : 'item_hp';
                    
                    const item = this.matter.add.sprite(e.x, e.y, dropType);
                    item.name = dropType; item.setSensor(true);
                    item.setCollisionCategory(C.CAT.ITEM); item.setCollidesWith([C.CAT.PLAYER]);
                    this.items.push(item);
                    this.gainXp(50);
                } else {
                    this.gainXp(2);
                }
                this.dataState.kills++;
                e.destroy();
                this.enemies = this.enemies.filter(obj => obj !== e);
                this.updateUI();
            }
        }

        hitPlayer(dmg) {
            if(this.time.now - this.lastHurtTime < C.PLAYER.INV_TIME) return;
            this.lastHurtTime = this.time.now;
            const curHp = this.player.getData('hp');
            const newHp = curHp - dmg;
            this.player.setData('hp', newHp);
            this.cameras.main.shake(150, 0.01);
            this.player.setTint(0xff0000);
            this.time.delayedCall(150, ()=>this.player.clearTint());
            this.updateUI();
            if(newHp <= 0) this.gameOver();
        }

        healPlayer(amount) {
            const cur = this.player.getData('hp');
            const max = this.player.getData('maxHp');
            this.player.setData('hp', Math.min(max, cur + amount));
            const txt = this.add.text(this.player.x, this.player.y - 30, "+" + amount, { color: '#0f0', fontSize: 20, fontStyle:'bold'}).setOrigin(0.5);
            this.tweens.add({targets:txt, y: this.player.y - 80, alpha:0, duration: 800, onComplete:()=>txt.destroy()});
            this.updateUI();
        }

        gainXp(val) {
            this.dataState.xp += val;
            if(this.dataState.xp >= this.dataState.nextXp) this.levelUp();
            this.updateUI();
        }

        updateTime() {
            if(this.isPaused) return;
            this.dataState.time++;
            const m = Math.floor(this.dataState.time / 60);
            const s = this.dataState.time % 60;
            document.getElementById('ui-time').innerText = `${m<10?'0':''}${m}:${s<10?'0':''}${s}`;
        }

        updateUI() {
            const hp = Math.max(0, this.player.getData('hp'));
            const max = this.player.getData('maxHp');
            document.getElementById('hp-text').innerText = `${Math.floor(hp)}/${Math.floor(max)}`;
            document.getElementById('hp-fill').style.width = `${(hp/max)*100}%`;
            document.getElementById('ui-kills').innerText = this.dataState.kills;
            document.getElementById('ui-lvl').innerText = this.dataState.level;
            const xpP = (this.dataState.xp / this.dataState.nextXp) * 100;
            document.getElementById('xp-fill').style.width = `${Math.min(100, xpP)}%`;
        }

        levelUp() {
            this.isPaused = true;
            this.matter.pause();
            const pool = [
                {t:"Â§öÈáçÊäïÊé∑", desc:"È™∞Â≠êÊï∞Èáè +1", fn:()=>this.build.diceCount++},
                {t:"ÁàÜÁ†¥‰∏ìÂÆ∂", desc:"ÁàÜÁÇ∏‰º§ÂÆ≥ +25%", fn:()=>this.build.explodeDmgMult += 0.25},
                {t:"ÈáçÂûãÊùêË¥®", desc:"ÊíûÂáª‰º§ÂÆ≥ +15", fn:()=>this.build.impactDmg += 15},
                // 3. ‰øÆÊîπÁÇπÔºöÂ∑®Â§ßÂåñÂ¢ûÂä†Ë¥®ÈáèÂíåÊíûÂáª‰º§ÂÆ≥
                {t:"Â∑®Â§ßÂåñ", desc:"‰ΩìÁßØ+25% ÊíûÂáª+20% Ë¥®ÈáèUP", fn:()=>{
                    this.build.size *= 1.25; 
                    this.build.impactDmg *= 1.2;
                    this.build.densityMult *= 1.25;
                }},
                {t:"È´òÁàÜÁÅ´ËçØ", desc:"ÁàÜÁÇ∏ËåÉÂõ¥ +20%", fn:()=>this.build.radius*=1.2},
                {t:"ÊûÅÈÄüË£ÖÂ°´", desc:"ÊîªÂáªÂÜ∑Âç¥ -15%", fn:()=>this.build.cooldown*=0.85},
                {t:"È´òÈÄüÈ©¨Ëææ", desc:"ÁßªÂä®ÈÄüÂ∫¶ +10%", fn:()=>{C.PLAYER.SPEED*=1.1;}},
                {t:"Á∫≥Á±≥Ê∂¶Êªë", desc:"ÊªëË°åË∑ùÁ¶ª +30%", fn:()=>this.build.friction*=0.7},
                {t:"Èí®ÈáëÂ§ñÂ£≥", desc:"ÂºπÈÅìÈÄüÂ∫¶ +20%", fn:()=>this.build.speed*=1.2},
                {t:"ÂÖâÊ£±ÈÄèÈïú", desc:"ÂÅ∂Êï∞ÊøÄÂÖâ‰º§ÂÆ≥ +50%", fn:()=>this.build.laserDmgMult += 0.5},
                {t:"Ê∂≤Ê∞ÆÂÆπÂô®", desc:"Â•áÊï∞ÂÜ∞ÂÜªÊ¶ÇÁéá +10%", fn:()=>this.build.freezeChance = Math.min(1.0, this.build.freezeChance + 0.1)},
                {t:"ÁîüÂëΩÂº∫Âåñ", desc:"ÊúÄÂ§ßHP +30 & Ê≤ªÁñó", fn:()=>{
                    const add = 30; 
                    const oldMax = this.player.getData('maxHp');
                    this.player.setData('maxHp', oldMax + add);
                    this.player.setData('hp', this.player.getData('hp') + add);
                }}
            ];
            const picks = Phaser.Utils.Array.Shuffle(pool).slice(0, 3);
            const div = document.getElementById('upgrade-container');
            div.innerHTML = '';
            picks.forEach(p => {
                const c = document.createElement('div');
                c.className = 'card';
                c.innerHTML = `<h3>${p.t}</h3><p>${p.desc}</p>`;
                c.onclick = () => {
                    p.fn();
                    this.dataState.level++;
                    this.dataState.xp = 0;
                    // 2. ‰øÆÊîπÁÇπÔºöÂçáÁ∫ßÊõ≤Á∫øÊõ¥Âπ≥Êªë (1.4 -> 1.25)
                    this.dataState.nextXp = Math.floor(this.dataState.nextXp * 1.25);
                    // 2. ‰øÆÊîπÁÇπÔºöÂà∑ÊÄ™È¢ëÁéáÂ¢ûÈïøÂèòÊÖ¢ (50 -> 30)
                    const newDelay = Math.max(C.SPAWN.MIN_DELAY, C.SPAWN.START_DELAY - (this.dataState.level * 30));
                    this.spawnEvent.delay = newDelay;
                    document.getElementById('screen-levelup').style.display = 'none';
                    this.isPaused = false;
                    this.matter.resume();
                    this.updateUI();
                };
                div.appendChild(c);
            });
            document.getElementById('screen-levelup').style.display = 'flex';
        }

        gameOver() {
            this.isPaused = true;
            this.matter.pause();
            const best = Math.max(parseInt(localStorage.getItem('pds_best')||0), this.dataState.kills);
            localStorage.setItem('pds_best', best);
            document.getElementById('end-kills').innerText = this.dataState.kills;
            document.getElementById('screen-over').style.display = 'flex';
        }
    }
    </script>
</body>
</html>
