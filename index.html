<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÁªùÂ¢ÉÈ™∞Â≠ê - V8.3 ÁåéÊùÄÂπ≥Ë°°Áâà</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@400;700&display=swap');

        body { margin: 0; padding: 0; background-color: #050505; overflow: hidden; font-family: 'Roboto Mono', monospace; user-select: none; -webkit-user-select: none; touch-action: none; color: white;}
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        /* Top Bar */
        .top-bar { display: flex; justify-content: space-between; align-items: flex-start; padding: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, transparent 100%); pointer-events: auto;}
        
        .btn-group { display: flex; gap: 10px; }
        .btn-hud {
            background: rgba(0, 20, 40, 0.8); border: 1px solid #00ffff; color: #00ffff; 
            padding: 8px 12px; border-radius: 4px; font-family: 'Orbitron', sans-serif; font-size: 12px;
            cursor: pointer; text-transform: uppercase; box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
            transition: all 0.1s; backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center;
        }
        .btn-hud:active { transform: scale(0.95); background: #00ffff; color: #000; }
        .btn-hud.muted { border-color: #555; color: #555; box-shadow: none; }

        .stat-box { text-align: right; text-shadow: 0 0 5px rgba(0,0,0,0.8); }
        .stat-big { font-family: 'Orbitron', sans-serif; font-size: 28px; font-weight: 900; color: #ffcc00; text-shadow: 0 0 10px rgba(255, 204, 0, 0.5); }
        .stat-small { font-size: 14px; color: #aaa; letter-spacing: 2px; }

        /* XP Bar */
        .xp-container { position: absolute; top: 70px; left: 50%; transform: translateX(-50%); width: 60%; height: 4px; background: #222; border: 1px solid #444; border-radius: 2px; overflow: hidden; box-shadow: 0 0 10px #000; }
        #xp-fill { width: 0%; height: 100%; background: #00ff00; box-shadow: 0 0 10px #00ff00; transition: width 0.2s; }
        #level-badge { position: absolute; top: 45px; left: 50%; transform: translateX(-50%); font-family: 'Orbitron'; font-size: 16px; color: #fff; text-shadow: 0 0 5px #00ff00; }

        /* Bottom Bar */
        .bottom-bar { padding: 30px; display: flex; justify-content: center; align-items: flex-end; pointer-events: none; }
        .hp-container { width: 320px; max-width: 90%; position: relative; transform: skew(-10deg); }
        .hp-track { width: 100%; height: 24px; background: rgba(20, 0, 0, 0.8); border: 2px solid #555; border-radius: 4px; overflow: hidden; position: relative; box-shadow: 0 0 15px rgba(0,0,0,0.8); }
        .hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #cc0000, #ff3333); transition: width 0.1s; box-shadow: 0 0 10px #ff0000; }
        .hp-text { position: absolute; top: -25px; left: 0; color: #ff3333; font-family: 'Orbitron'; font-weight: bold; font-size: 18px; text-shadow: 1px 1px 0 #000; }

        /* Overlays */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,5,10,0.9); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; pointer-events: auto; backdrop-filter: blur(8px); }
        
        .title-text { font-family: 'Orbitron'; font-size: 42px; color: #ffcc00; margin: 0; text-shadow: 0 0 20px rgba(255, 204, 0, 0.6); text-align: center; line-height: 1.1; }
        .sub-text { color: #00ffff; letter-spacing: 3px; margin-top: 10px; font-size: 14px; opacity: 0.8; }
        
        .btn-primary { 
            margin-top: 40px; padding: 15px 50px; font-family: 'Orbitron'; font-size: 24px; font-weight: 900; 
            background: #ffcc00; color: #000; border: none; transform: skew(-10deg); cursor: pointer; 
            box-shadow: 0 0 25px rgba(255, 204, 0, 0.4); transition: 0.2s; 
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
        }
        .btn-primary:hover { transform: skew(-10deg) scale(1.05); background: #fff; box-shadow: 0 0 40px rgba(255, 204, 0, 0.8); }
        .btn-primary:active { transform: skew(-10deg) scale(0.95); }

        .btn-secondary {
            margin-top: 20px; padding: 10px 30px; font-family: 'Orbitron'; font-size: 18px;
            background: transparent; border: 2px solid #fff; color: #fff; cursor: pointer;
            transform: skew(-10deg); transition: 0.2s;
        }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }

        /* Upgrade Cards */
        .card-grid { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; max-width: 900px; padding: 20px; }
        .card { 
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a); 
            border: 1px solid #444; width: 180px; padding: 20px; border-radius: 6px; cursor: pointer; 
            display: flex; flex-direction: column; align-items: center; text-align: center; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.6); transition: 0.2s; position: relative; overflow: hidden;
        }
        .card::before { content:''; position:absolute; top:0; left:0; width:100%; height:4px; background:#00ffff; }
        .card:hover { border-color: #00ffff; transform: translateY(-8px); box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); }
        .card h3 { color: #ffcc00; font-family: 'Orbitron'; font-size: 16px; margin: 10px 0; }
        .card p { font-size: 12px; color: #bbb; line-height: 1.5; margin: 0; }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="btn-group">
                <button class="btn-hud" id="btn-control" onclick="toggleControl()">üïπÔ∏è ÊëáÊùÜ</button>
                <button class="btn-hud" style="border-color:#ff3333; color:#ff3333;" onclick="togglePause()">‚è∏Ô∏è</button>
                <button class="btn-hud" id="btn-sound" onclick="toggleMute()">üîä</button>
            </div>
            <div class="stat-box">
                <div class="stat-big">‚ò†Ô∏è <span id="ui-kills">0</span></div>
                <div class="stat-small" id="ui-time">00:00</div>
            </div>
        </div>
        
        <div id="level-badge">SYS.LVL <span id="ui-lvl">1</span></div>
        <div class="xp-container"><div id="xp-fill"></div></div>

        <div class="bottom-bar">
            <div class="hp-container">
                <div class="hp-text" id="hp-text">100%</div>
                <div class="hp-track">
                    <div class="hp-fill" id="hp-fill"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-start" class="overlay">
        <div class="title-text">PROJECT<br>DICE SURVIVOR</div>
        <div class="sub-text">V8.3 // BALANCED</div>
        <div style="margin-top:20px; color:#aaa;">ÂéÜÂè≤ÊúÄ‰Ω≥: <span id="best-score" style="color:#fff; font-weight:bold;">0</span></div>
        <button class="btn-primary" onclick="gameStart()">INITIATE</button>
    </div>

    <div id="screen-pause" class="overlay" style="display: none; background: rgba(0,0,0,0.6);">
        <h1 class="title-text" style="font-size:30px;">SYSTEM PAUSED</h1>
        <button class="btn-primary" onclick="togglePause()">RESUME</button>
        <button class="btn-secondary" onclick="location.reload()">ABORT</button>
    </div>

    <div id="screen-levelup" class="overlay" style="display: none;">
        <h2 class="title-text" style="font-size: 30px;">UPGRADE MODULE</h2>
        <div class="sub-text">SELECT AUGMENTATION</div>
        <div class="card-grid" id="upgrade-container"></div>
    </div>

    <div id="screen-over" class="overlay" style="display: none;">
        <h1 class="title-text" style="color:#ff3333;">CRITICAL FAILURE</h1>
        <h2 style="color:#fff; font-family:'Orbitron'; margin-top:20px;">KILLS: <span id="end-kills" style="color:#ffcc00;">0</span></h2>
        <button class="btn-primary" onclick="location.reload()">REBOOT</button>
    </div>

    <script>
    class SoundSys {
        constructor() {
            this.ctx = null;
            this.masterGain = null;
            this.initialized = false;
            this.muted = false;
        }
        init() {
            if(this.initialized) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.3; 
            this.masterGain.connect(this.ctx.destination);
            this.initialized = true;
            if(this.ctx.state === 'suspended') this.ctx.resume();
        }
        toggleMute() {
            this.muted = !this.muted;
            if(this.masterGain) this.masterGain.gain.value = this.muted ? 0 : 0.3;
            const btn = document.getElementById('btn-sound');
            btn.innerText = this.muted ? 'üîá' : 'üîä';
            btn.classList.toggle('muted', this.muted);
        }
        playTone(freq, type, duration, vol = 1, slide = 0) {
            if(!this.initialized || this.muted) return;
            try {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if(slide !== 0) osc.frequency.exponentialRampToValueAtTime(Math.max(10, freq + slide), this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            } catch(e) {}
        }
        sfxExplode(size) { 
            if(!this.initialized || this.muted) return;
            try {
                const duration = 0.5 + size * 0.1;
                const bufferSize = Math.floor(this.ctx.sampleRate * duration);
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufferSize);
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, this.ctx.currentTime);
                filter.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + duration);
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(1.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            } catch(e) {}
        }
        sfxShoot() { this.playTone(600, 'square', 0.1, 0.4, -300); }
        sfxHit() { this.playTone(200, 'triangle', 0.05, 0.3, -100); }
        sfxHurt() { this.playTone(100, 'sawtooth', 0.3, 0.8, -50); }
        sfxLevelUp() { if(this.muted) return; let t=0; [440,554,659,880].forEach((f,i)=> setTimeout(()=>this.playTone(f,'sine',0.2,0.4), i*80)); }
        sfxDie() { this.playTone(200, 'sawtooth', 1.0, 0.8, -180); }
        sfxFreeze() { this.playTone(1200, 'sine', 0.4, 0.3, -600); }
        sfxLaser() { this.playTone(800, 'sawtooth', 0.15, 0.3, 400); }
    }
    
    const audio = new SoundSys();

    const C = {
        MAP_SIZE: 2500,
        ZOOM: 0.6,
        PLAYER: { HP: 100, SPEED: 8, INV_TIME: 100 }, 
        SPAWN: { START_DELAY: 1000, MIN_DELAY: 150 },
        CAT: { PLAYER: 1, ENEMY: 2, DIE: 4, BULLET: 8, WALL: 16, ITEM: 32 }
    };

    let game, scene;
    let inputMode = 'joystick';
    document.getElementById('best-score').innerText = localStorage.getItem('pds_best') || 0;

    function gameStart() {
        audio.init();
        document.getElementById('screen-start').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'flex';
        
        game = new Phaser.Game({
            type: Phaser.AUTO,
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: '#050505',
            scale: { mode: Phaser.Scale.RESIZE },
            physics: {
                default: 'matter',
                matter: { 
                    gravity: { y: 0 }, 
                    positionIterations: 6, velocityIterations: 4,
                    runner: { isFixed: true, fps: 60 } 
                } 
            },
            scene: MainScene
        });
    }

    function toggleControl() {
        inputMode = inputMode === 'joystick' ? 'click' : 'joystick';
        document.getElementById('btn-control').innerText = inputMode === 'joystick' ? 'üïπÔ∏è ÊëáÊùÜ' : 'üéØ ÁÇπÂáª';
        if(scene) scene.resetInput();
    }

    function togglePause() {
        if(!scene || scene.isGameOver || scene.isLevelingUp) return;
        scene.isPaused = !scene.isPaused;
        if(scene.isPaused) {
            scene.matter.pause();
            document.getElementById('screen-pause').style.display = 'flex';
        } else {
            scene.matter.resume();
            document.getElementById('screen-pause').style.display = 'none';
            scene.resetInput();
        }
    }

    function toggleMute() { audio.toggleMute(); }

    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            const gen = (k, c, w, h, type, glow=false) => {
                if(this.textures.exists(k)) return;
                const g = this.make.graphics({add:false});
                if(glow) { g.fillStyle(c, 0.3); if(type==='rect') g.fillRect(-4,-4,w+8,h+8); else g.fillCircle(w/2, h/2, w/2+4); }
                g.fillStyle(c, 1); g.lineStyle(2, 0xffffff);
                if(type === 'rect') { g.fillRect(0,0,w,h); g.strokeRect(0,0,w,h); }
                if(type === 'circle') { g.fillCircle(w/2,h/2,w/2); g.strokeCircle(w/2,h/2,w/2); }
                if(type === 'tri') { g.beginPath(); g.moveTo(w/2,0); g.lineTo(w,h); g.lineTo(0,h); g.closePath(); g.fillPath(); g.strokePath(); }
                g.generateTexture(k, w+(glow?8:0), h+(glow?8:0));
            };

            gen('player', 0x00ffff, 32, 32, 'rect', true);
            gen('enemy', 0xff3333, 28, 28, 'rect');
            gen('enemy_s', 0x9933ff, 32, 32, 'tri');
            gen('enemy_e', 0xff8800, 96, 96, 'rect');
            gen('bullet', 0xffaa00, 14, 14, 'circle', true); 
            gen('item_hp', 0x00ff00, 24, 24, 'rect');
            gen('item_xp', 0xffd700, 28, 28, 'circle');
            
            const g = this.make.graphics({add:false});
            g.lineStyle(2, 0x222222); g.strokeRect(0,0,128,128);
            g.generateTexture('grid', 128, 128);

            this.generateDiceTextures();
        }

        generateDiceTextures() {
            const size = 64; 
            const positions = {
                1: [[0.5, 0.5]],
                2: [[0.25, 0.25], [0.75, 0.75]],
                3: [[0.25, 0.25], [0.5, 0.5], [0.75, 0.75]],
                4: [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]],
                5: [[0.25, 0.25], [0.75, 0.25], [0.5, 0.5], [0.25, 0.75], [0.75, 0.75]],
                6: [[0.25, 0.2], [0.75, 0.2], [0.25, 0.5], [0.75, 0.5], [0.25, 0.8], [0.75, 0.8]]
            };
            for (let i = 1; i <= 6; i++) {
                if (this.textures.exists(`die_${i}`)) continue;
                const g = this.make.graphics({add: false});
                g.fillStyle(0xeeeeee); g.fillRoundedRect(0, 0, size, size, 8);
                g.lineStyle(4, 0xaaaaaa); g.strokeRoundedRect(0, 0, size, size, 8);
                g.fillStyle(0x111111);
                positions[i].forEach(pos => g.fillCircle(size * pos[0], size * pos[1], 6));
                g.generateTexture(`die_${i}`, size, size);
            }
        }

        create() {
            scene = this;
            this.matter.world.setBounds(0, 0, C.MAP_SIZE, C.MAP_SIZE);
            
            const wT = 2000; const mid = C.MAP_SIZE/2;
            const wOpt = { isStatic: true, label: 'wall', render: { visible: false } };
            [
                this.matter.add.rectangle(mid, -wT/2, C.MAP_SIZE, wT, wOpt),
                this.matter.add.rectangle(mid, C.MAP_SIZE+wT/2, C.MAP_SIZE, wT, wOpt),
                this.matter.add.rectangle(-wT/2, mid, wT, C.MAP_SIZE, wOpt),
                this.matter.add.rectangle(C.MAP_SIZE+wT/2, mid, wT, C.MAP_SIZE, wOpt)
            ].forEach(w => w.collisionFilter = { category: C.CAT.WALL });

            this.grid = this.add.tileSprite(mid, mid, C.MAP_SIZE+2000, C.MAP_SIZE+2000, 'grid').setDepth(-10);
            this.add.rectangle(mid, mid, C.MAP_SIZE, C.MAP_SIZE).setStrokeStyle(8, 0xff0000, 0.3).setDepth(-5);

            this.player = this.matter.add.sprite(mid, mid, 'player');
            this.player.name = 'player'; 
            this.player.setFixedRotation().setFrictionAir(0.15).setDensity(5).setDepth(100);
            this.player.setCollisionCategory(C.CAT.PLAYER);
            this.player.setCollidesWith([C.CAT.ENEMY, C.CAT.BULLET, C.CAT.WALL, C.CAT.ITEM]); 
            this.player.setData('hp', C.PLAYER.HP);
            this.player.setData('maxHp', C.PLAYER.HP);

            this.cameras.main.setZoom(C.ZOOM);
            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);

            this.dataState = { level: 1, xp: 0, nextXp: 10, kills: 0, time: 0 };
            // REDUCED RADIUS TO 65 (Approx 50% of previous 120)
            this.build = { 
                diceCount: 1, size: 1.0, speed: 1.0, radius: 65, cooldown: 1000, 
                friction: 0.05, impactDmg: 20, 
                laserDmgMult: 1.0, freezeChance: 0.2, explodeDmgMult: 1.0, densityMult: 1.0 
            };
            
            this.enemies = []; this.diceList = []; this.items = [];
            this.lastHurtTime = 0;
            this.isPaused = false;
            this.isGameOver = false;
            this.isLevelingUp = false;

            this.setupInput();
            this.setupCollisions();

            this.time.addEvent({ delay: 1000, loop: true, callback: this.updateTime, callbackScope: this });
            this.spawnEvent = this.time.addEvent({ delay: C.SPAWN.START_DELAY, loop: true, callback: this.spawnEnemy, callbackScope: this });
            this.hpGraphics = this.add.graphics().setDepth(150);
            this.updateUI();
        }

        setupCollisions() {
            const check = (pair, n1, n2, cb) => {
                const a = pair.bodyA.gameObject, b = pair.bodyB.gameObject;
                if (!a || !b) return;
                if ((a.name === n1 && b.name === n2)) cb(a, b);
                else if ((b.name === n1 && a.name === n2)) cb(b, a);
            };

            this.matter.world.on('collisionstart', (event) => {
                event.pairs.forEach(pair => {
                    check(pair, 'die', 'enemy', (die, enemy) => {
                        if(!die.active || !enemy.active) return;
                        const isElite = enemy.getData('type') === 'elite';
                        if(isElite) {
                             const dmg = this.build.impactDmg * 2; 
                             this.showDmg(enemy.x, enemy.y, dmg, '#fff');
                             this.hitEnemy(enemy, dmg);
                             if (!die.exploded) { 
                                 die.exploded = true; die.setTint(0xffaa00);
                                 this.time.delayedCall(100, () => { if(die.active) this.explodeDie(die); });
                             }
                        } else if (die.body.speed > 0.5) {
                            this.hitEnemy(enemy, this.build.impactDmg);
                            audio.sfxHit();
                            const impact = this.add.circle(die.x, die.y, 20, 0xffffff, 0.6).setDepth(200);
                            this.tweens.add({targets:impact, scale:0.2, alpha:0, duration:100, onComplete:()=>impact.destroy()});
                        }
                    });
                    check(pair, 'player', 'bullet', (p, b) => { this.hitPlayer(b.getData('dmg')); b.destroy(); });
                    check(pair, 'bullet', 'wall', (b, w) => { b.destroy(); });
                    
                    check(pair, 'player', 'item_hp', (p, item) => { 
                        this.healPlayer(30); item.destroy(); 
                        Phaser.Utils.Array.Remove(this.items, item);
                        audio.playTone(600, 'sine', 0.1);
                    });
                    check(pair, 'player', 'item_xp', (p, item) => { 
                        this.gainXp(100); item.destroy();
                        Phaser.Utils.Array.Remove(this.items, item);
                        audio.playTone(800, 'square', 0.05, 0.1);
                    });
                });
            });

            this.matter.world.on('collisionactive', (event) => {
                event.pairs.forEach(pair => {
                    check(pair, 'player', 'enemy', (p, e) => { if (!e.getData('frozen')) this.hitPlayer(e.getData('dmg')); });
                    check(pair, 'die', 'enemy', (die, enemy) => {
                        if (die.body.speed > 0.2 && scene.time.now % 10 === 0 && enemy.getData('type') !== 'elite') {
                            this.hitEnemy(enemy, 1); 
                        }
                    });
                });
            });
        }

        setupInput() {
            this.input.keyboard.on('keydown-Q', toggleControl);
            this.joyStick = { active: false, x: 0, y: 0, vec: new Phaser.Math.Vector2() };
            this.clickDest = null;
            this.marker = this.add.circle(0,0,10,0x00ff00).setVisible(false).setDepth(90);
            this.joyBase = this.add.circle(0,0,60,0xffffff,0.1).setScrollFactor(0).setVisible(false).setDepth(999);
            this.joyThumb = this.add.circle(0,0,30,0xffffff,0.5).setScrollFactor(0).setVisible(false).setDepth(999);

            this.input.on('pointerdown', p => {
                if(this.isPaused || this.isGameOver || p.y < 80) return;
                if(inputMode === 'click') {
                    const wp = this.cameras.main.getWorldPoint(p.x, p.y);
                    this.clickDest = new Phaser.Math.Vector2(wp.x, wp.y);
                    this.marker.setPosition(wp.x, wp.y).setVisible(true);
                } else {
                    this.joyStick.active = true;
                    this.joyStick.x = p.x; this.joyStick.y = p.y;
                    this.joyBase.setPosition(p.x, p.y).setVisible(true);
                    this.joyThumb.setPosition(p.x, p.y).setVisible(true);
                }
            });
            this.input.on('pointermove', p => {
                if(this.joyStick.active) {
                    const d = Phaser.Math.Distance.Between(this.joyStick.x, this.joyStick.y, p.x, p.y);
                    const a = Phaser.Math.Angle.Between(this.joyStick.x, this.joyStick.y, p.x, p.y);
                    const dist = Math.min(d, 60);
                    this.joyThumb.x = this.joyStick.x + Math.cos(a)*dist;
                    this.joyThumb.y = this.joyStick.y + Math.sin(a)*dist;
                    this.joyStick.vec.set(Math.cos(a), Math.sin(a));
                }
            });
            this.input.on('pointerup', () => {
                this.joyStick.active = false;
                this.joyBase.setVisible(false); this.joyThumb.setVisible(false);
                this.joyStick.vec.set(0,0);
            });
        }

        resetInput() {
            this.clickDest = null;
            this.joyStick.active = false;
            this.joyBase.setVisible(false); this.joyThumb.setVisible(false);
            this.player.setVelocity(0);
        }

        update(t, dt) {
            if(this.isPaused || this.isGameOver) return;
            
            this.grid.tilePositionX = this.cameras.main.scrollX;
            this.grid.tilePositionY = this.cameras.main.scrollY;
            this.drawHpBars();

            if(inputMode === 'click' && this.clickDest) {
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.clickDest.x, this.clickDest.y);
                if(dist > 10) {
                    const a = Phaser.Math.Angle.Between(this.player.x, this.player.y, this.clickDest.x, this.clickDest.y);
                    this.player.setVelocity(Math.cos(a)*C.PLAYER.SPEED, Math.sin(a)*C.PLAYER.SPEED);
                } else {
                    this.player.setVelocity(0); this.clickDest = null; this.marker.setVisible(false);
                }
            } else if (inputMode === 'joystick') {
                this.player.setVelocity(this.joyStick.vec.x * C.PLAYER.SPEED, this.joyStick.vec.y * C.PLAYER.SPEED);
            }
            
            const b = 40; 
            this.player.setX(Phaser.Math.Clamp(this.player.x, b, C.MAP_SIZE-b));
            this.player.setY(Phaser.Math.Clamp(this.player.y, b, C.MAP_SIZE-b));

            if(!this.nextFire || t > this.nextFire) {
                this.fireDice();
                this.nextFire = t + this.build.cooldown;
            }

            this.enemies.forEach(e => {
                if(!e.active) return;
                if (e.getData('frozen')) { e.setVelocity(0, 0); return; }
                
                const dist = Phaser.Math.Distance.Between(e.x, e.y, this.player.x, this.player.y);
                if(e.data.get('type') === 'shooter' && dist < 450) {
                    if(t > e.data.get('nextShot')) {
                        this.fireEnemyBullet(e);
                        e.data.set('nextShot', t + 2500);
                    }
                    e.setVelocity(e.body.velocity.x * 0.9, e.body.velocity.y * 0.9); 
                } else {
                    const angle = Phaser.Math.Angle.Between(e.x, e.y, this.player.x, this.player.y);
                    const speed = e.data.get('speed');
                    e.setVelocity(Math.cos(angle)*speed, Math.sin(angle)*speed);
                }
            });

            // CLEANUP AND EXPLODE LOGIC
            for (let i = this.diceList.length - 1; i >= 0; i--) {
                const d = this.diceList[i];
                // FIX: If exploded, remove from update list immediately to avoid conflicts
                if (d.exploded) { this.diceList.splice(i, 1); continue; }
                
                d.life++;
                // Force cleanup if stuck for too long (5s)
                if (d.life > 300) { d.exploded = true; this.explodeDie(d); this.diceList.splice(i,1); continue; }

                if (t > d.nextRollTime && d.body.speed > 1) {
                    d.setTexture(`die_${Phaser.Math.Between(1, 6)}`);
                    d.nextRollTime = t + 80;
                }
                if(d.body.speed < 1.0 && d.life > 10) {
                    this.explodeDie(d);
                    this.diceList.splice(i, 1);
                }
            }
        }

        drawHpBars() {
            this.hpGraphics.clear();
            this.enemies.forEach(e => {
                if (!e.active || e.getData('type') !== 'elite') return;
                const max = e.getData('maxHp'); const cur = e.getData('hp');
                const pct = Phaser.Math.Clamp(cur/max, 0, 1);
                const x = e.x - 40; const y = e.y - e.height/2 - 20;
                this.hpGraphics.fillStyle(0x000000, 0.8); this.hpGraphics.fillRect(x, y, 80, 8);
                this.hpGraphics.fillStyle(0xff0000, 1); this.hpGraphics.fillRect(x+1, y+1, 78*pct, 6);
            });
        }

        spawnEnemy() {
            if(this.isPaused || this.isGameOver) return;
            let count = 1 + Math.floor(this.dataState.level / 5);
            
            // DYNAMIC SCALING
            const timeMin = this.dataState.time / 60;
            const baseDmg = 8 + (this.dataState.level * 0.5) + (timeMin * 2);
            // HP Multiplier based on Level AND Time
            const hpMult = 1 + (this.dataState.level * 0.15) + (timeMin * 0.3);

            for(let i=0; i<count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = 1000;
                let x = Phaser.Math.Clamp(this.player.x + Math.cos(angle) * r, 100, C.MAP_SIZE-100);
                let y = Phaser.Math.Clamp(this.player.y + Math.sin(angle) * r, 100, C.MAP_SIZE-100);

                let type = 'enemy', hp = 10, speed = 4 + Math.random(), density = 0.5, dmg = baseDmg;
                let isElite = false;
                const roll = Math.random();
                if(roll < 0.05) { type = 'enemy_e'; hp = 200; speed = 2; isElite = true; density = 20; dmg = baseDmg * 2; } 
                else if (roll < 0.25) { type = 'enemy_s'; hp = 15; speed = 3; dmg = baseDmg * 0.8; }

                // Apply HP scaling
                hp = hp * hpMult;

                const e = this.matter.add.sprite(x, y, type);
                e.name = 'enemy'; 
                e.setData({ type: isElite?'elite':(type==='enemy_s'?'shooter':'chaser'), hp, maxHp:hp, speed, frozen:false, dmg: Math.floor(dmg) });
                if(type==='enemy_s') e.setData('nextShot', this.time.now + 1000);

                e.setCollisionCategory(C.CAT.ENEMY);
                e.setCollidesWith([C.CAT.PLAYER, C.CAT.DIE, C.CAT.WALL, C.CAT.ENEMY]);
                e.setDensity(density).setFrictionAir(0.05);
                this.enemies.push(e);
            }
        }

        fireEnemyBullet(e) {
            if (e.getData('frozen')) return; 
            const b = this.matter.add.sprite(e.x, e.y, 'bullet');
            b.name = 'bullet'; b.setSensor(true); b.setData('dmg', e.getData('dmg'));
            b.setCollisionCategory(C.CAT.BULLET); b.setCollidesWith([C.CAT.PLAYER, C.CAT.WALL]);
            const a = Phaser.Math.Angle.Between(e.x, e.y, this.player.x, this.player.y);
            b.setVelocity(Math.cos(a)*7, Math.sin(a)*7).setFrictionAir(0); 
            this.time.delayedCall(3500, ()=> { if(b.active) b.destroy(); });
        }

        fireDice() {
            audio.sfxShoot();
            for(let i=0; i<this.build.diceCount; i++) {
                this.time.delayedCall(i*100, () => {
                    let angle = 0; let nearest = null; let minD = 999999;
                    this.enemies.forEach(e => {
                        if (!e.active) return;
                        const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, e.x, e.y);
                        if (d < minD) { minD = d; nearest = e; }
                    });

                    if (nearest && minD < 800) angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, nearest.x, nearest.y);
                    else if (this.player.body.speed > 0.5) angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                    else angle = Math.random() * 6.28;
                    
                    angle += Phaser.Math.FloatBetween(-0.1, 0.1);
                    const spawnX = this.player.x + Math.cos(angle) * 50;
                    const spawnY = this.player.y + Math.sin(angle) * 50;
                    const size = 30 * this.build.size;
                    
                    const d = this.matter.add.sprite(spawnX, spawnY, 'die_1');
                    d.name = 'die'; d.life = 0; d.finalPoint = Phaser.Math.Between(1, 6); d.nextRollTime = 0; d.exploded = false;
                    d.setBody({type: 'rectangle', width: size, height: size});
                    d.setDisplaySize(size, size); 
                    d.setCollisionCategory(C.CAT.DIE).setCollidesWith([C.CAT.ENEMY, C.CAT.WALL]);
                    d.setBounce(0.4).setFrictionAir(this.build.friction).setDensity(20 * this.build.densityMult); 
                    
                    const spd = 12 * this.build.speed;
                    d.setVelocity(Math.cos(angle)*spd, Math.sin(angle)*spd);
                    d.setAngularVelocity(Math.random() * 0.5 - 0.25);
                    this.diceList.push(d);
                });
            }
        }

        explodeDie(d) {
            // Safety check: if d is undefined or already destroyed, exit
            if(!d || !d.active) return;
            d.exploded = true; // Double flag to be safe
            
            const ex = d.x; const ey = d.y; const point = d.finalPoint;
            
            // Disable body immediately
            d.setCollisionCategory(0).setVelocity(0,0).setStatic(true).setVisible(false);

            audio.sfxExplode(point);

            const radius = this.build.radius * [0.5, 0.8, 1.2, 1.8, 2.5, 3.5][point-1]; 
            let dmg = this.build.impactDmg * point * this.build.explodeDmgMult;
            
            let color = 0xffffff;
            if (point <= 2) color = 0xaaaaaa;
            else if (point <= 4) color = 0xffaa00;
            else if (point === 5) color = 0xff0000;
            else { color = 0x00ffff; dmg *= 1.5; } 

            this.cameras.main.shake(200, point*0.005);
            this.showDmg(ex, ey - 25, point, color===0x00ffff?'#0ff':'#fff', point===6?40:24);

            const flash = this.add.circle(ex, ey, radius, color, 0.8).setDepth(300);
            this.tweens.add({targets: flash, alpha: 0, scale: 1.1, duration: 150, onComplete: ()=>flash.destroy()});
            
            const shockwave = this.add.graphics().setDepth(300);
            this.tweens.add({
                targets: shockwave, scaleX: radius/10, scaleY: radius/10, alpha: 0, duration: 300,
                onUpdate: () => { 
                    shockwave.clear(); shockwave.lineStyle(point === 6 ? 10 : 4, color, shockwave.alpha);
                    shockwave.strokeCircle(ex, ey, 10); 
                }, onComplete: () => shockwave.destroy()
            });

            const activeEnemies = [...this.enemies]; 
            
            if (point % 2 === 0) {
                let nearest = null; let minD = 600; 
                activeEnemies.forEach(e => {
                    if (!e.active) return;
                    const dist = Phaser.Math.Distance.Between(ex, ey, e.x, e.y);
                    if (dist < minD) { minD = dist; nearest = e; }
                });
                if (nearest) {
                    audio.sfxLaser();
                    const laser = this.add.graphics().setDepth(301);
                    laser.lineStyle(point * 2, 0x00ffff, 1); laser.lineBetween(ex, ey, nearest.x, nearest.y);
                    this.tweens.add({targets: laser, alpha: 0, duration: 300, onComplete: ()=>laser.destroy()}); 
                    this.hitEnemy(nearest, dmg * 1.5 * this.build.laserDmgMult);
                }
            }
            
            let freeze = (point % 2 !== 0 && Math.random() < this.build.freezeChance);
            if(freeze) audio.sfxFreeze();

            activeEnemies.forEach(e => {
                if(!e.active) return; 
                const dist = Phaser.Math.Distance.Between(ex, ey, e.x, e.y);
                if(dist <= radius) {
                    const angle = Phaser.Math.Angle.Between(ex, ey, e.x, e.y);
                    e.applyForce({x:Math.cos(angle)*0.1*this.build.size*(point/3), y:Math.sin(angle)*0.1*this.build.size*(point/3)});
                    this.hitEnemy(e, dmg);
                    if (freeze && e.active) {
                        e.setData('frozen', true); e.setTint(0x00aaff); 
                        this.time.delayedCall(2000, () => { if (e.active) { e.setData('frozen', false); e.clearTint(); }});
                    }
                }
            });
            // FORCE DESTROY
            if(d.active) d.destroy();
        }

        showDmg(x, y, dmg, color, size=16) {
            const txt = this.add.text(x, y, Math.floor(dmg), { fontFamily:'Orbitron', fontSize: size, fontStyle: 'bold', color: color, stroke: '#000', strokeThickness: 2 }).setOrigin(0.5).setDepth(400);
            this.tweens.add({targets:txt, y:y-40, alpha:0, duration:600, onComplete:()=>txt.destroy()});
        }

        hitEnemy(e, dmg) {
            if (!e.active) return;
            let hp = e.getData('hp');
            hp -= dmg;
            e.setData('hp', hp);
            if(hp <= 0) {
                if(e.getData('type') === 'elite') {
                    const hpCount = this.items.filter(i => i.active && i.name === 'item_hp').length;
                    let type = (hpCount >= 5) ? 'item_xp' : 'item_hp';
                    const item = this.matter.add.sprite(e.x, e.y, type);
                    item.name = type; item.setSensor(true);
                    item.setCollisionCategory(C.CAT.ITEM); item.setCollidesWith([C.CAT.PLAYER]);
                    this.items.push(item);
                    this.gainXp(50);
                } else {
                    this.gainXp(2);
                }
                this.dataState.kills++;
                e.destroy();
                Phaser.Utils.Array.Remove(this.enemies, e);
                this.updateUI();
            }
        }

        hitPlayer(dmg) {
            if(this.time.now - this.lastHurtTime < C.PLAYER.INV_TIME) return;
            this.lastHurtTime = this.time.now;
            audio.sfxHurt();
            const curHp = this.player.getData('hp');
            const newHp = curHp - dmg;
            this.player.setData('hp', newHp);
            this.cameras.main.shake(150, 0.01);
            this.player.setTint(0xff0000);
            this.time.delayedCall(150, ()=>this.player.clearTint());
            this.updateUI();
            if(newHp <= 0) this.gameOver();
        }

        healPlayer(amount) {
            const cur = this.player.getData('hp'); const max = this.player.getData('maxHp');
            this.player.setData('hp', Math.min(max, cur + amount));
            this.updateUI();
            const txt = this.add.text(this.player.x, this.player.y-30, "+"+amount, {fontFamily:'Orbitron', color:'#0f0', fontSize:20}).setOrigin(0.5).setDepth(400);
            this.tweens.add({targets:txt, y:this.player.y-80, alpha:0, duration:800, onComplete:()=>txt.destroy()});
        }

        gainXp(val) {
            this.dataState.xp += val;
            if(this.dataState.xp >= this.dataState.nextXp) this.levelUp();
            this.updateUI();
        }

        updateTime() {
            if(this.isPaused || this.isGameOver) return;
            this.dataState.time++;
            const m = Math.floor(this.dataState.time / 60);
            const s = this.dataState.time % 60;
            document.getElementById('ui-time').innerText = `${m<10?'0':''}${m}:${s<10?'0':''}${s}`;
        }

        updateUI() {
            const hp = Math.max(0, this.player.getData('hp')); const max = this.player.getData('maxHp');
            document.getElementById('hp-text').innerText = Math.floor(hp);
            document.getElementById('hp-fill').style.width = `${(hp/max)*100}%`;
            document.getElementById('ui-kills').innerText = this.dataState.kills;
            document.getElementById('ui-lvl').innerText = this.dataState.level;
            document.getElementById('xp-fill').style.width = `${Math.min(100, (this.dataState.xp / this.dataState.nextXp) * 100)}%`;
        }

        levelUp() {
            this.isLevelingUp = true;
            this.isPaused = true;
            this.matter.pause();
            audio.sfxLevelUp();

            const pool = [
                {t:"Â§öÈáçÊäïÊé∑", desc:"È™∞Â≠êÊï∞Èáè +1", fn:()=>this.build.diceCount++},
                {t:"ÁàÜÁ†¥‰∏ìÂÆ∂", desc:"ÁàÜÁÇ∏‰º§ÂÆ≥ +25%", fn:()=>this.build.explodeDmgMult += 0.25},
                {t:"ÈáçÂûãÊùêË¥®", desc:"ÊíûÂáª‰º§ÂÆ≥ +15", fn:()=>this.build.impactDmg += 15},
                {t:"Â∑®Â§ßÂåñ", desc:"‰ΩìÁßØ+25% ÊíûÂáª+20% Ë¥®ÈáèUP", fn:()=>{this.build.size *= 1.25; this.build.impactDmg *= 1.2; this.build.densityMult *= 1.25;}},
                {t:"È´òÁàÜÁÅ´ËçØ", desc:"ÁàÜÁÇ∏ËåÉÂõ¥ +20%", fn:()=>this.build.radius*=1.2},
                {t:"ÊûÅÈÄüË£ÖÂ°´", desc:"ÊîªÂáªÂÜ∑Âç¥ -15%", fn:()=>this.build.cooldown*=0.85},
                {t:"È´òÈÄüÈ©¨Ëææ", desc:"ÁßªÂä®ÈÄüÂ∫¶ +10%", fn:()=>{C.PLAYER.SPEED*=1.1;}},
                {t:"Á∫≥Á±≥Ê∂¶Êªë", desc:"ÊªëË°åË∑ùÁ¶ª +30%", fn:()=>this.build.friction*=0.7},
                {t:"Èí®ÈáëÂ§ñÂ£≥", desc:"ÂºπÈÅìÈÄüÂ∫¶ +20%", fn:()=>this.build.speed*=1.2},
                {t:"ÂÖâÊ£±ÈÄèÈïú", desc:"ÂÅ∂Êï∞ÊøÄÂÖâ‰º§ÂÆ≥ +50%", fn:()=>this.build.laserDmgMult += 0.5},
                {t:"Ê∂≤Ê∞ÆÂÆπÂô®", desc:"Â•áÊï∞ÂÜ∞ÂÜªÊ¶ÇÁéá +10%", fn:()=>this.build.freezeChance = Math.min(1.0, this.build.freezeChance + 0.1)},
                {t:"ÁîüÂëΩÂº∫Âåñ", desc:"ÊúÄÂ§ßHP +30 & Ê≤ªÁñó", fn:()=>{ const add = 30; this.player.setData('maxHp', this.player.getData('maxHp')+add); this.player.setData('hp', this.player.getData('hp')+add);}}
            ];
            const picks = Phaser.Utils.Array.Shuffle(pool).slice(0, 3);
            const div = document.getElementById('upgrade-container');
            div.innerHTML = '';
            picks.forEach(p => {
                const c = document.createElement('div');
                c.className = 'card';
                c.innerHTML = `<h3>${p.t}</h3><p>${p.desc}</p>`;
                c.onclick = () => {
                    p.fn();
                    this.dataState.level++; this.dataState.xp = 0;
                    this.dataState.nextXp = Math.floor(this.dataState.nextXp * 1.25);
                    this.spawnEvent.delay = Math.max(C.SPAWN.MIN_DELAY, C.SPAWN.START_DELAY - (this.dataState.level * 30));
                    document.getElementById('screen-levelup').style.display = 'none';
                    this.isPaused = false; this.isLevelingUp = false;
                    this.matter.resume(); this.updateUI();
                };
                div.appendChild(c);
            });
            document.getElementById('screen-levelup').style.display = 'flex';
        }

        gameOver() {
            this.isGameOver = true;
            this.matter.pause();
            audio.sfxDie();
            const best = Math.max(parseInt(localStorage.getItem('pds_best')||0), this.dataState.kills);
            localStorage.setItem('pds_best', best);
            document.getElementById('end-kills').innerText = this.dataState.kills;
            document.getElementById('screen-over').style.display = 'flex';
        }
    }
    </script>
</body>
</html>
